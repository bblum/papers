%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The 15-410 Curriculum}
\label{sec:curriculum}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The work described takes place in the context of a
Computer Science class called
15-410, Operating System Design and Implementation.
It is designed for juniors and seniors in Computer Science
and Electrical and Computer Engineering.
For CS students it is one of five courses which fulfill
the ``Software Systems'' requirement (at present, the others
are Compiler Design,
Parallel Computer Architecture and Programming,
Distributed Systems,
and Computer Networks.
The prerequisite course is 15-213,
Introduction to Computer Systems,
a course which has been adopted at other
universities in the U.S.\ and worldwide~\cite{sigcse01:CSaPP}.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% XXX How do we say politely "Some M.S. students
% manage to pass it too"?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
In this section we will discuss the course learning
objectives,
outline the programming projects,
discuss our use of Wind River Simics as the
the basic simulation/debugging environment
and our approaches to grading,
and close by mentioning current limitations in the scope
of the course material.

%% TODO: Nwf says "vary widely" does not read as intended. -- bblum
The course learning objectives vary widely.
%
Students study high-level concepts
such as protection (least privilege, access control lists vs.
capabilities)
and
file-system internals,
and log-based storage.
%
Emphasis is placed on acquiring information from ``primary sources,''
including both manufacturer-provided hardware documentation
and a non-textbook technical-literature reading assignment.
%
Students begin with a ``blank slate'' rather than a
kernel-source template or an existing operating system,
so they must synthesize design requirements from multiple sources
and are provided with an opportunity to 
decide on module boundaries and inter-module conventions
themselves.
%
Due to the foundational nature of kernel code,
assignment design and grading encourage students to
think about corner cases, including resource exhaustion,
instead of being satisfied by ``the right basic idea''
implementations that handle only auspicious situations.
%
Finally, most relevant to this work,
students gain substantial experience in
analyzing and writing lock-based multi-threaded code and
thread-synchronization objects, including detecting and documenting race conditions and deadlock,
including
the relationship between interrupts and other forms of concurrency.

%=== Projects ===%
\subsection{Projects}

In the course of a semester, students work on five
programming assignments; the first two are individual,
and the remaining three are the products of two-person
teams.

\subsubsection{Stack Crawler}
The first project is a ``stack crawler'':  invoked by
a client program, it displays the program's stack
symbolically, rendering saved program-counter values
as function names and printing function parameters
in accordance with their types.
This project meets a variety of goals:
it enables students to review key process-model and
language-runtime concepts from the
prerequisite course;
it introduces students to our expectations about
design, analysis, and making choices;
finally,
because C pointers are unsafe, it requires students
to consider robustness.
%
% and we READ THEIR CODE
This project is built using a standard C tool chain
and debugged as students see fit (generally using
a combination of \x{printf()} and \x{gdb}).
%% TODO I've been using "\x{printf()}" for code, an alias for \lstinline I
%% adopted from the Rust paper template. We should be consistent because
%% the font sizes are different (and maybe make \x{}'s font bigger too,
%% what do you think?). -- bblum

\subsubsection{Device Drivers and Game}
The second project is a simple game, such as Hangman,
which runs standalone (without an underlying
operating system).
We provide students with selected C~library routines
(\x{strcmp()}, \x{memmove()}, \x{printf()});
they write a device-driver library consisting of
console output (to a memory-mapped text-mode video display),
keyboard input (interrupt driven),
and a countdown timer.
The game, which varies by semester, provides students
with the ability to test their drivers.
%
% and the need to write enough code to get into trouble
%
This project and the remaining ones are written in
C with a bit of x86-32 assembly code,
compiled and linked into an ELF executable,
stored into a 1.44-megabyte 3.5-inch floppy-disk image,
and booted via GRUB.
The floppy-disk image can be copied to a real floppy disk
or embedded into an ``El Torito'' bootable compact disc image,
in which case it can be booted on standard PC hardware.
However, students most often boot the floppy image
using the Simics system emulator (described below).

\subsubsection{User-space Thread Library}
The third project is implementing a 1:1 thread library for
user-space programs.
The library specification is essentially a stripped-down
version of POSIX Pthreads.
The primary goal of the project is providing students
with a laboratory for
experimenting with concurrency and atomicity.
Students begin by designing mutexes using any
x86-32 atomic instructions they choose
(there is substantial variation across groups).
They then write other thread-synchronization
primitives (condition variables, semaphores,
and reader/writer locks), infrastructure
components (stack allocation/recycling and
a thread registry),
and low-level code to launch and shut down
threads.
Another goal is encouraging students to carefully
consider how ingredients are assembled into
abstractions.
%% Good rhetoric (below). -- bblum
One example of this is a semantic gap
between the library-level \x{thr_create()}
call, analogous to \x{pthread_create()},
and the \x{thread_fork} system call provided
by the underlying kernel,
which takes no parameters,
makes no changes to the user's address space,
and cannot meaningfully
be invoked from C~code.
Because these abstractions are so different,
students have the opportunity to
understand each as an independent entity while
deciding how to bridge them.
A similar deliberate semantic gap exists between
\x{cond_wait()} and the system call
which suspends execution of a thread.

Student library code is linked against small
test programs provided by the course staff,
producing one statically linked ELF executable
per test program.
The test programs are bundled into a RAM-disk
image and linked against a kernel written by
the course staff
and provided in binary form.

The behavior of the reference kernel is specified
via a twelve-page document~\cite{kspec}.
% the handout for the thread library project itself
% is nineteen pages and includes not only a specification
% of the thread-library primitives but also
% a suggested implementation plan, grading guidelines,
% optional design challenges, etc.
In addition to providing a reliable execution
substrate,
this ``reference kernel'' schedules
the execution of user-space threads created by
student code according to a variety of
interleaving patterns.
In order to aid debugging of concurrency problems,
% students can manually select among these
% interleaving patterns.
the kernel offers a variety of (specification-conformant, yet deliberately undocumented) interleaving policies;
the \x{misbehave()} system call is provided to select the current global policy.

\subsubsection{Pebbles Kernel}
For the fourth project, two-student teams
implement a kernel which complies to the
same specification as the reference kernel
they previously relied on.
They implement some approach to
synchronizing and blocking threads while
they are in kernel space,
a simple round-robin scheduler,
basic virtual memory,
a program loader,
code to handle various x86 exceptions,
and code for setting up and tearing down
threads and processes.
Students re-use the basic device drivers
they implemented in the second project.
%% TODO Space permitting, maybe have a table of system calls?
%% The 410 section is otherwise lacking in visual aids. -- bblum
These ingredients are combined to yield
twenty-five system calls
(life-cycle, thread management, memory management,
console I/O, and miscellaneous),
which are summarized in Figure~\ref{fig:syscalls}.

%% TODO Justify by mentioning average lines of code. -- bblum
For most students in the class, this is the
largest and most complicated software artifact they
have produced.
%% TODO Huh? I don't get how the sentence below is supposed to flow.
%% Seems like it wants to elaborate on the concerns, but the next sentence
%% is different. -- bblum
Because the test suite and the grading criteria
emphasize robustness and preemptibility of
kernel code,
there are many cross-cutting concerns.
%
%% TODO: Dave, is it OK to say the following sentence? -- bblum
Widely regarded as the most difficult concurrency problem in the project
is that of coordinating a parent and a child task that ``simultaneously''
invoke \x{vanish()}: the parent task must reassign ownership of the child to
\x{init}, the root process, while the child task must check its parent's state
for any \x{wait()}ing threads which need to be woken up.
Many solutions, due to design constraints imposed by other parts of the kernel,
are prone to data races or deadlocks without careful thought.
%
Because the students are responsible for ensuring
the run-time invariants underlying all compiler-generated
code in the system (kernel and user-space),
they gain experience with debugging at both the
``algorithm level'' and the register/bit-field level.

\begin{figure}
	\center \footnotesize
	\begin{tabular}{|l|p{0.28\textwidth}|}
		\hline
		\bf System call name & \bf Summary \\
		\hline
		\multicolumn{2}{c}{\em Lifecycle management} \\
		\hline
		\x{fork} & Duplicates the invoking task, including all memory regions. \\
		\x{thread_fork} & Creates a new thread in the current task.\\
		\x{exec} & Replaces the program currently running in the invoking task with a new one specified. \\
		\x{set_status} & Records the exit status of the current task. \\
		\x{vanish} & Terminates execution of the calling thread. \\
		\x{wait} & Blocks execution until another task terminates, and collects its exit status.\\
		\x{task_vanish}* & Causes all threads of a task to \x{vanish}. \\
		\hline
		\multicolumn{2}{c}{\em Thread management} \\
		\hline
		\x{gettid} & Returns the ID of the invoking thread. \\
		\x{yield} & Defers execution to a specified thread. \\
		\x{deschedule} & Blocks execution of the invoking thread. \\
		\x{make_runnable} & Wakes up another \x{deschedule}d thread. \\
		\x{get_ticks} & Gets the number of timer ticks since bootup. \\
		\x{sleep} & Blocks a thread for a given number of ticks. \\
		\x{swexn} & Registers a given user-space function as a software exception handler.\\
		\hline
		\multicolumn{2}{c}{\em Memory management} \\
		\hline
		\x{new_pages} & Allocates a specified region of memory. \\
		\x{remove_pages} & Deallocates same. \\
		\hline
		\multicolumn{2}{c}{\em Console I/O} \\
		\hline
		\x{getchar}* & Reads one character from keyboard input. \\
		\x{readline} & Reads the next line from keyboard input. \\
		\x{print} & Prints a given memory buffer to the console. \\
		\x{set_term_color} & Sets the color for future console output. \\
		\x{set_cursor_pos} & Sets the console cursor location. \\
		\x{get_cursor_pos} & Retrieves the console cursor location. \\
		\hline
		\multicolumn{2}{c}{\em Miscellaneous} \\
		\hline
		\x{ls} & Loads a given buffer with the names of files stored in the RAM disk ``file system''. \\
		\x{halt} & Ceases execution of the operating system. \\
		\x{misbehave}* & Selects among several behaviors for thread interleaving in certain scenarios. \\
		\hline
	\end{tabular}
	\caption{The Pebbles specifcation defines 25 system calls. Students are not required to implement ones marked with an asterisk (*), though the reference kernel provides them. }
	\label{fig:syscalls}
\end{figure}

\subsubsection{Pebbles Extension}
Students who complete the kernel project on time
then work on a smaller kernel-extension project
with various content depending on the semester.
Past projects have included
writing a sound card driver,
hibernation (suspend to disk),
kernel profiling,
and writing an in-kernel debugger.
Two recent, more aggressive projects have been
adding paravirtualization so that their kernels
can host guest kernels and
addding multi-processor support to their single-processor kernels.
Meanwhile, students who were unable to complete
the kernel project on time receive additional time
to finish up and improve their code quality---this
requirement is based on our belief that important
learning experiences are obtained by solving the
hard problems,
which turn up at the end of the implementation.

%=== Simics ===%
\subsection{Simics}

As mentioned above, the main execution and debugging
platform used in the class is
Simics~\cite{simics},
originally developed by the Swedish Institute of
Computer Science and
currently a product of Wind River.
Unlike some emulators,
which focus on fast execution of correct code,
Simics
provides very faithful bit-level support
not only for code that behaves correctly but
also for code that is ``incorrect within reason.''
Occasionally student code manages to invoke an unsupported
function of some hardware device or even to cause the
simulator to crash, but this is quite rare, and in almost
every case when the ``bad event'' is characterized it turns
out that what the software requested from the hardware was
a mistake.
Meanwhile, inside its large envelope, Simics supports
\textit{very} detailed models of various x86 processors.
Unlike hardware virtualization environments,
Simics contains substantial debugger support:
single-stepping,
printing of source-level symbolic
expressions,
stack tracing,
display of TLB entries,
and even summaries of x86 hardware-defined descriptor tables.
Unlike some symbolic debuggers,
Simics is scriptable in Python,
and it is possible to interpose user-written measurement
frameworks to evaluate proposed hardware
%% TODO Fix citations. But also, maybe this mention isn't relevant and
%% could be left out (if we're in space trouble?) -- bblum
features~\cite{UW-GEMS,SimFlex,FeS2}.
Performance is very reasonable (Simics can simulate certain
cases, such as a CPU halted awaiting a clock interrupt,
much faster than real time).
%% TODO: One huge advantage of simics over QEMU that we should mention is
%% that QEMU only issues timer interrupts at basic block boundaries. -- bblum

% ability to quickly write small debugging-support snippets
% in a few lines of Python (e.g., report the function name
% every time a RET instruction is executed)

%=== Grading ===%
\subsection{Grading}

Pebbles kernels are graded in three ways: passing the ``hurdle'', running an automated test suite, and undergoing manual inspection by course staff.

\subsubsection{Hurdle}
%% TODO: Dave, write about the criteria (and what it means, i.e., "getting a shell up and running, getting processes to exit")
The hurdle is a set of criteria that Pebbles implementations must meet to be considered sastisfactory
(TODO: what are they?).
Towards the end of the kernel project, students fill out the ``hurdle form'', a checklist of these criteria.
Students who pass the hurdle are permitted to turn in their kernels and move on to the final, shorter, project; otherwise, they must spend the remaining two weeks continuing to work towards the hurdle.
The hurdle criteria constitute 50\% of the kernel project's grade.

\subsubsection{Automated tests}
We run submitted kernels in an automated testing harness. The test suite is a number of userspace programs which test functionality ranging from the basic process lifecycle, to robustness against corner-case security vulnerabilities, to long-term stability under large stress tests.
Performance on these tests constitutes 30\% of the kernel project's grade.

Of course, due to the nondeterministic nature of many common bugs in student code, these tests are unable to verify a submission's correctness with complete certainty.
(This hit-or-miss nature motivated our work on Landslide.)

\subsubsection{Manual inspection}
Finally, both to make up for the tests' incompleteness and to provide personalized human feedback, each student kernel is manually graded by a member of course staff.
The instructors and teaching assistants print out each group's submitted kernel and mark it with red ink, auditing the code for code style, architectural issues, race conditions, and preemptibility.
After the inking process, each group meets with the staff member who graded them for an hour-long ``kernel interview'', essentially a debriefing in which any final misconceptions the students might have can be rectified.
Staff discretionary points constitute 20\% of the kernel project's grade.

%=== Limitations ===%
\subsection{Limitations}

At present the course accepts the following limitations
or core assumptions.

\subsubsection{x86}

Students write code that runs on one specific
hardware platform.
We target x86 PCs because machines of this type are
available from many manufacturers at many price points.
This means that it is easy for students to obtain access
to a machine (virtual or real) which will let them boot
up their code, type commands, and observe the results.
Also, unlike many System-on-a-Chip platforms,
detailed hardware descriptions are readily available.
% rather than being proprietary or "documented"
% by labyrinthine Linux source code
Finally, the platform is fairly stable---with only a
little care, it is possible to write a compliant
kernel which runs on anything newer than a 486DX cpu,
i.e., almost any PC hardware which is likely to be in
working condition.

\subsubsection{32-Bit}

The course still targets the 32-bit
subset of the x86 platform, for three reasons.
%% TODO I'm not sure I believe this is an advantage. Instead of having
%% to verify if each register is correct, students now have to verify
%% both registers and stack slots. Otherwise this paragraph is good. -- bblum
First, while the small number of registers is
frustrating for compiler writers,
from the point of view of OS students,
the existence of fewer registers means less work
when it is necessary to verify that each register's
value is correct.
Likewise, the old-fashioned focus on the stack
makes it easier to track function parameter values.
Second, implementing virtual memory on x86-64 as
opposed to x86-32 requires more code and more
debugging time without imparting greater insight.
Finally, since it is impossible for an x86 processor
to be in 64-bit mode with virtual memory off,
students would need to be coached through the
32-bit--to--64-bit transition or would need
to be given a template virtual-memory implementation.
All in all, at present we are satisifed with
the 32-bit choice.

\subsubsection{Memory Model}

At present we allow students
to reason about concurrency based on a
sequentially-consistent view of
memory, which is consistent with
existing x86 hardware~\cite{SewellSOZNM:x86tso-cacm10}
but simplistic compared to most other
architectures.
Lecture material educates students about the
general topic of out-of-order memory systems
and fencing,
but at present the hands-on experience does not
reinforce that material.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The Pebbles Kernel Specification}
\label{sec:pebbles}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The kernel that students implement is loosely based on the
Unix model: \x{fork()}, \x{exec()}, and \x{wait()}.
We adopt the Mach~\cite{DBLP:conf/usenix/AccettaBBGRTY86}
distinction between ``tasks,''
which are resource containers,
and threads,
each of which executes within a single task.
This partitioning is a different approach from that of
Plan~9's \x{rfork()} or Linux's \x{clone()},
which allow a continuum of sharing between
identical threads and independent processes,
at the cost of implementation complexity which we wish to avoid.
A task's address space can be edited through two system
calls that add and delete contiguous regions of memory.
Students are expected to implement zero-fill-on-demand,
but copy-on-write and demand-loading of executables are
optional.
Threads can print text to and read lines of text from
the simple console that students implemented at
the start of the semester.

Within a task, threads are created using the
\x{thread_fork} system call, which closely
mirrors the specification of \x{fork()}:
the new thread begins with an exact copy of the
register values of the old thread, except that
the return-value register, \x{\%eax}, contains
zero;
in the old thread, the return value is the thread i.d.\
of the newly created thread.
This minimal formulation defers all policy decisions
(e.g., stack size, location, and contents) to the
user-space thread library.
A thread may suspend its execution via the
\x{deschedule()} system call,
and a blocked thread can be reactivated via
\x{make_runnable()}.

Each thread has the ability to register a handler
for hardware exceptions (illegal instruction,
division by zero, etc.)
via the \x{swexn()} system call,
which specifies the addresses of handler code
and a handler stack.
When a thread encounters an exception,
the kernel reflects the exception to user space
by
de-registering the handler,
pushing the thread's register state onto the stack,
and invoking the handler code.
The handler has the ability to re-register itself
(or register some other handler),
to run arbitrary code,
and/or to atomically adopt a new set of register
values.
The \x{swexn()} facility is used to enable
the thread library to detect when a managed
thread has crashed
and, more importantly,
to enable user-space
implementation of automatically-growing stack
regions.
Removing the auto-stack policy and mechanism from
its traditional position in Unix-like kernels
was done because it simplfies the kernel and
``front-loads'' the policy question to an earlier
part of the course,
before students are facing the substantial pressure
of the kernel project.
