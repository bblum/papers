\section{Design}

TODO

Unlike in chess AI, however, adding more preemption points to a completed state space is not necessarily a linear process, as  % blah blah multiple combinations

% TODO: Introduce abbreviation for SSS-MC here

% define minimal state space and maximal state space

\subsection{Filtering false positive data races}

{\bf Terminology.}
Importantly, we distinguish data-race {\em candidates} and data-race {\em bugs}.
Because data-race analysis is false-positive-prone, Landslide reports unprotected access pairs separately from the problems listed above, calling the pair a {\em data race candidate}.
Should a future interleaving, preempting during those accesses, cause a failure (e.g. assertion or deadlock), then we report a {\em data-race bug}.
Otherwise, if the access pair can be reordered, but does not produce a failure under any interleaving, it is a {\em benign data race}.
If they cannot be reordered at all, it is a {\em false positive}.
For brevity, we classify benign data races as a subset of false positives.


% TODO: proof goes here
% TODO: example codez with malloc re free go here

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Implementation}

\subsection{Landslide}
\label{sec:landslide}

We chose \landslide~\cite{landslide} as our stateless model checker due to its ability to trace program execution at the granularity of individual instructions and memory accesses, which is mandatory for data-race analysis~\cite{eraser}.
% optional: cite tsan above
\landslide~features Dynamic Partial Order Reduction (DPOR) \cite{dpor}, state space estimation \cite{estimation}, and data-race detection.
It avoids state space cycles (e.g. ad-hoc synchronization with {\tt yield()} or even {\tt xchg} loops) similarly to Fair-Bounded Search \cite{bpor}.
% this line can be cut if space is needed
It can test both user- and kernel-level code, though the latter requires user annotations and is limited to timer-driven nondeterminism.
Its bug-detection metrics include assertion failures, deadlock, segfaults, heap checking (like Valgrind~\cite{valgrind}), and a heuristic infinite loop/livelock checker.

{\bf Data races in lock implementations.}
Prior work data race tools recognize the implementations of sync primitives to avoid spuriously flagging memory accesses resulting from the lock implementation itself \cite{tsan}.
Assuming the locks are already correct enables productive data-race analysis on the rest of the codebase.
With testing limited to one execution, even if you wished to test for lock bugs, data-race analysis would still uselessly flag every single access pair in the lock implementation, requiring human attention to verify.
However, Iterative Deepening can automatically verify a large quantity of data-race candidates as benign.
Hence, we extended \landslide~with a custom option to change the lock-set tracking to include accesses from {\tt mutex\_lock()} and {\tt mutex\_unlock()} in the analysis. (Accesses from other sync functions, such as {\tt cond\_wait()}, would be either included already, or protected by an internal mutex.)
% TODO: Add a code sample showing how the lockset boundaries change? If there's room?

\subsection{Managing multiple state spaces}

\quicksand~uses a workqueue model
...
priorities... data race priorities...


% If there's room, mention the cant_swap mechanism for killing the top half of deferred jobs.

{\bf Avoiding thrashing in \quicksand.} % TODO

% TODO: decide which subsection should come first for better flow

\subsection{Data-race preemption points}

% Intuitively, % TODO describe what we're trying to achieve % do this in design section

When \landslide~detects a data race, it reports each of the two memory accesses involved in the race.
Each report indicates the program counter value (PC) associated with the access, as well as some further conditions to help filter away unrelated executions of the same instruction on different data.
(For example, {\tt list\_insert()} might be called from many parts of a codebase, but produce data-race candidates from only one callsite.)
Ideally, the PC would be qualified by a full backtrace, but tracing the stack is too expensive to do for each shared memory access.
Instead, \landslide~qualifies the PC with
(a) the current thread ID and
(b) the most recent {\tt call} instruction.
% (a crude approximation of a stack trace)
% which are much cheaper, as we carry them around all the time already
Note that we do {\em not} qualify data races by the shared memory address,
which can change based on different interleavings of previous code
(for example, depending on the result of {\tt malloc()}).
% especially when malloc is involved.
% TODO: decide whether to make dont-filter-dr-by-address example.
%Figure~\ref{fig:dont-filter-dr-by-address} shows example code where qualifying by memory address will miss the bug.


When \quicksand~receives a data race report, it adds two new jobs to its workqueue:
a ``small'' job to preempt on the racing instruction only,
and a ``big'' job to preempt on that instruction as well as each PP used by the reporting job.
%
Hence each {\em pair} of racing accesses will spawn four new jobs, as shown in Figure~\ref{fig:new-dr-jobs}.
Rather than adding a maximal job with both new PPs at once, we prefer to add smaller jobs which have a higher chance of completing in time.
If those state spaces are bug-free, they will in turn add the maximal job later.
%
The rationale of spawning multiple jobs is that which will be more fruitful cannot be known in advance:
while the big job risks not completing in time,
the small job risks missing the data race entirely if the original PPs were required to expose it.
In practice, we observed some bugs found quickly by these small jobs, and other bugs missed by the small jobs found eventually by the big jobs.
% which justifies this design


% TODO: make new-dr-jobs diagram

%                                  (2)          landslide         landslide
%  landslide                   "Preempt when-->  o  PPs=[foo]      o  PPs=[mutex_lock,
%    o  PPs=[mutex_lock]        PC = FOO"       / \               / \      foo]
%   / \                              |         o   o             o   o
%  o  /\                             |                          /|\  |\
%    o  o                                                      o o o o o
%                             __QUICKSAND__
%    |       (1)             |             |           (3)
%    \  "Hey, an access      |  job1       | ----"Preempt when -->
%     '- at FOO raced w/ --> |        job2 |      PC = BAR"
%        one at BAR!         |    job4     |
%                            |        job70|      [ same pictures for s/foo/bar/]
%                            | job8        |
%                            '-------------'
%                maybe show some internal structore of QS as well

% TODO: Decide whether to discuss the fact that we don't add the 2nd of a "suspected" dr pair until it is confirmed.
