\section{Design}

TODO

Unlike in chess AI, however, adding more preemption points to a completed state space is not necessarily a linear process, as  % blah blah multiple combinations

% define minimal state space and maximal state space

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Implementation}

% TODO: Overview

\subsection{Managing multiple state spaces}

Landslide provides estimated completion time using the Recursive Estimator algorithm in \cite{estimation}.

{\bf Avoiding thrashing in \quicksand.} % TODO

% TODO: decide which subsection should come first for better flow

\subsection{Data-race preemption points}

Intuitively, % TODO describe what we're trying to achieve

When \landslide~detects a data race, it produces a report for each of the two memory accesses involved in the race.
Each report indicates the program counter value (PC) associated with the access, as well as some further conditions to help filter away unrelated executions of the same instruction on different data.
(For example, {\tt list\_insert()} might be called from many parts of a codebase, but produce data-race candidates from only one callsite.)
Ideally, the PC would be qualified by a full backtrace, but tracing the stack is too expensive to do as often as each shared memory access.
Instead, \landslide~qualifies the PC with
(a) the current thread ID and
(b) the most recent {\tt call} instruction.
% (a crude approximation of a stack trace)
% which are much cheaper, as we carry them around all the time already
Note that we do {\em not} qualify data races by {\em memory addresses},
which change across thread interleavings.
% especially when malloc is involved.
Figure~\ref{fig:dont-filter-dr-by-address} shows example code where qualifying by memory address will miss the bug.

% TODO: make dont-filter-dr-by-address example.

When \quicksand~receives a data race report, it adds two new jobs to its workqueue:
a ``small'' job to preempt on the racing instruction only,
and a ``big'' job to preempt on that instruction as well as each PP used by the reporting job.
%
Hence each {\em pair} of racing accesses will spawn four new jobs, as shown in Figure~\ref{fig:new-dr-jobs}.
Rather than adding a maximal job with both new PPs at once, we prefer to add smaller jobs which have a higher chance of completing in time.
If those state spaces are bug-free, they will in turn add the maximal job later.
%
The rationale of spawning multiple jobs is that which will be more fruitful cannot be known in advance: while the big job may not complete in time, the small job might miss the data race entirely if the original PPs were required to expose it.
In practice, we have observed some bugs found quickly by the small job, and other bugs missed by the small job found eventually by the big job.
% which justifies this design


% TODO: make new-dr-jobs diagram

%                                  (2)          landslide         landslide
%  landslide                   "Preempt when-->  o  PPs=[foo]      o  PPs=[mutex_lock,
%    o  PPs=[mutex_lock]        PC = FOO"       / \               / \      foo]
%   / \                              |         o   o             o   o
%  o  /\                             |                          /|\  |\
%    o  o                                                      o o o o o
%                             __QUICKSAND__
%    |       (1)             |             |           (3)
%    \  "Hey, an access      |  job1       | ----"Preempt when -->
%     '- at FOO raced w/ --> |        job2 |      PC = BAR"
%        one at BAR!         |    job4     |
%                            |        job70|      [ same pictures for s/foo/bar/]
%                            | job8        |
%                            '-------------'
%                maybe show some internal structore of QS as well
