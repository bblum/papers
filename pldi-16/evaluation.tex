% TODO: Abbreviate SMC, and fixed-PP approach.

\section{Evaluation}

% TODO: Don't forget to add to quicksand a feature to print time-when-job-started (ie, tell total time from test start to bug found in a DR state space == job-start time + job-elapsed time)
% TODO ******BEFORE****** you begin running experimence en masse!

Although \quicksand~presents Iterative Deepening and data-race PPs as interconnected techniques, they each could theoretically be employed alone in other model checkers.
For example, a single-state-space tool could use data-race candidates during immediately subsequent interleavings, essentially changing the state space on the fly.
Likewise, a message-passing-only tool could employ Iterative Deepening despite data races being absent from its concurrency model.
Hence, though many of our experiments compare \quicksand~to the state-of-the-art as a whole,
we also sought to evaluate each technique individually.
Our evaluation answers the following questions:
\begin{enumerate}
	\item Is combining data-race analysis with stateless model checking productive?
		\begin{enumerate}
			\item Do data-race PPs expose new bugs that couldn't be found with single-state-space model checking?
				% Elaborate later:
				% Among those, how many were missed in a {\em completed} execution of the otherwise ``maximal'' state space?
			\item Do we avoid false positives compared to single-pass?
				% Explain later as:
				% How many data-race candidates were verified as benign
				% Also Include:
				% How many false positives does the free-re-malloc technique suppress?
			% TODO: This one's optional. You can give up on it.
			\item Do we avoid false negatives compared to single-pass?
				% Explain later as: How many data-race bugs required backtracking to be identified as candidates in the first place
				%(don't forget set EXPLORE_BACKWARDS=0 here)
		\end{enumerate}
	\item Is Iterative Deepening better than the single-state-space model?
		\begin{enumerate}
			\item Does Iterative Deepening find bugs
				% in subset state spaces
				faster than the single-state-space approach, even without data races?
			\item Does Iterative Deepening help test data-race PPs?
				% Are there some DRs where the PP alone finds the bug, while the superset SS cannot, and some vice versa?
				% What we want is a *variety*, which proves that iterative deepening is better than either individual strategy.
		\end{enumerate}
\end{enumerate}

\subsection{Evaluating Data-Race PPs}

\subsection{Evaluating Iterative Deepening}


% Figure out concretely what the data race tricks are that we do, so we can claim them as contributions in the paper. Then ACTUALLY EVALUATE THEM.
%         - Speculative DR PPs.
%                 Not a heuristic, rather how to make it work at all to begin with.
%                 (Cite MS thesis, claim on backwards explorating finding bugs faster)
%         - Free/re-malloc to eliminate some false positives. See #193.
%                 Measure how many false positives are eliminated.
%                 Check, ofc, to make ABSOLUTE SURE, that no bugs missed w/ this trick.
%                         If there are, it could be because of the implementation
%                         bug described in #193.
%         - Using tid/last_call filtering because whole stack traces are too expensive.
%                 Moderately optional, 1st priority since theoretically interesting:
%                 Turn on/off and measure how resulting DR bug #s change.
%         - Optional: Reprioritizing DRs based on "confirmed" / "suspected"
%                 Shouldn't be hard just make ID wrapper print "s" or "c"!
%                 Is it helpful for ID to put priorities on DR PPs?
%                         Test by inverting the priority and see if fewer buges are found.
%         // Super optional to talk about. Probably not worth the time.
%         // - "Too suspicious" (during init/destroy)
%         //      (Cite eraser, section 2.2)

We tested 87 pintos kernels and found races in 45-47 of them, among which 34-47 of those bugs required data-race preemption points to expose. That means we rock.

% TODO: Future work.
% Future work: Add a way to configure even smaller subsets (eg "only mutex_locks called from site X") for cases where mx_lock and mx_unlock alone are still too big. Count the number of kernels for which this was the case.
